// ILQ (Interleaved Lattice Qubits)
// Routing for layered quantum architectures with vertical stacking

RouteInfo:
    routed_gates = CX, T
    GateRealization{path : Vec<Location>}
    realize_gate = map(|x| -> GateRealization{path = x}, 
        if (Gate.gate_type()) == CX 
        then 
            if ((State.map[Gate.qubits[0]]) / Arch.stack_size) == ((State.map[Gate.qubits[1]]) / Arch.stack_size)
            then 
                all_paths(Arch, 
                    (Vec()).push(State.map[Gate.qubits[0]]), 
                    (Vec()).push(State.map[Gate.qubits[1]]), 
                    Vec())
            else 
                all_paths(Arch,
                    fold(Vec(), 
                        |x, acc| -> acc.extend(x),
                        map(|k| -> 
                            map(|n| -> ((n) * Arch.stack_size) + k, 
                                vertical_neighbors((State.map[Gate.qubits[0]]) / Arch.stack_size, Arch.width, Arch.height)),
                            (0..Arch.stack_size))),
                    horizontal_neighbors(State.map[Gate.qubits[1]], Arch.width), 
                    ((values(State.map())).extend(Arch.magic_state_qubits()))
                        .extend(fold(Vec(), |x, acc| -> acc.extend(x), 
                            map(|x| -> x.implementation.(path()), State.implemented_gates()))))
        else   
            all_paths(Arch, 
                vertical_neighbors(State.map[Gate.qubits[0]], Arch.width, Arch.height), 
                fold(Vec(), |x, acc| -> acc.extend(x), 
                    map(|x| -> horizontal_neighbors(x, Arch.width), Arch.magic_state_qubits())), 
                ((values(State.map())).extend(Arch.magic_state_qubits()))
                    .extend(fold(Vec(), |x, acc| -> acc.extend(x),
                        map(|x| -> x.implementation.(path()), State.implemented_gates())))))

TransitionInfo:
    Transition{na : Location}
    get_transitions = (Vec()).push(Transition{na = Location(0)})
    apply = identity_application(step)
    cost = 0.0

ArchInfo:
    Arch{magic_state_qubits : Vec<Location>, alg_qubits : Vec<Location>, width : Int, height : Int, stack_size : Int}
    get_locations = Arch.alg_qubits()

StateInfo:
    cost = 1.0
